## PROMPT

([PROMPT TEMPLATE](../README.md#ai-prompt-template-works-well-with-chatgpt) HERE)

Create a simple short URL API with the following framework:

The ShortURLRegist API registers a URL in Redis and generates a unique short sid for each URL.
The sid is generated by incrementing a Redis counter (using INCR) and encoding the resulting number in base64.

When someone accesses /s/:sid, the API redirects them to the original registered URL.

## ChatGPT RESULT

Here's a **simple short URL API** using the `allino` framework as described:

---

### 1. **ShortURLRegist API** – Registers a long URL and returns a short ID

```go
type ShortURLRegistInput struct {
	URL string `form:"url" validate:"required,url"`
}

type ShortURLRegistOutput struct {
	SID string `json:"sid"` // short ID
}

var ShortURLRegist = allino.NewTypedAPI("/api/shorten",
	func(r *allino.Request, input *ShortURLRegistInput) (*ShortURLRegistOutput, error) {
		if r.Redis == nil {
			return nil, &allino.CodeError{StatusCode: 500, Code: "no_redis", Msg: "Redis not available"}
		}

		// Increment counter
		id, err := r.Redis.Incr(r.Context(), "shorturl:counter").Result()
		if err != nil {
			return nil, &allino.CodeError{StatusCode: 500, Code: "incr_failed", Msg: err.Error()}
		}

		// Encode ID to base64 (URL-safe, no padding)
		sid := base64.RawURLEncoding.EncodeToString([]byte(fmt.Sprintf("%d", id)))

		// Store the original URL in Redis under shorturl:sid:<sid>
		key := "shorturl:sid:" + sid
		err = r.Redis.Set(r.Context(), key, input.URL, 0).Err()
		if err != nil {
			return nil, &allino.CodeError{StatusCode: 500, Code: "store_failed", Msg: err.Error()}
		}

		return &ShortURLRegistOutput{SID: sid}, nil
	})
```

---

### 2. **Redirect Handler** – Redirects `/s/:sid` to the original URL

```go
type ShortURLRedirectInput struct {
	SID string `path:"sid" validate:"required"`
}

var ShortURLRedirect = allino.NewTypedUI("/s/:sid",
	func(r *allino.Request, input *ShortURLRedirectInput) (string, error) {
		if r.Redis == nil {
			return "", &allino.CodeError{StatusCode: 500, Code: "no_redis", Msg: "Redis not available"}
		}

		key := "shorturl:sid:" + input.SID
		url, err := r.Redis.Get(r.Context(), key).Result()
		if err == redis.Nil {
			return "", &allino.RedirectError{StatusCode: 302, Location: "/404"}
		} else if err != nil {
			return "", &allino.CodeError{StatusCode: 500, Code: "redis_error", Msg: err.Error()}
		}

		// Redirect to original URL
		return "", &allino.RedirectError{StatusCode: 302, Location: url}
	})
```

---

### Redis Keys Used

* `shorturl:counter`: An integer counter for generating new sids.
* `shorturl:sid:<sid>`: Stores the long URL for each sid.

---

Let me know if you want:

* A custom base62 encoder instead of base64.
* URL expiration support.
* User authentication integration (`r.User()`).
* OpenAPI documentation annotations (via `HandlerOption`).
